using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace hierarchy_test_util
{
    class ClassHierarchy
    {
        private Random m_rand = new Random(3);
        private string m_hierarchyName;
        private List<ClassEntry> m_classes = new List<ClassEntry>();

        private PropertyFactory m_propFactory;
        private double m_vTableChance, m_vBaseChance;

        public ClassHierarchy(string i_hierarchyName, double i_vTableChance, double i_vBaseChance, int i_classCount)
        {
            m_hierarchyName = i_hierarchyName;
            m_vTableChance = i_vTableChance;
            m_vBaseChance = i_vBaseChance;
            m_propFactory = new PropertyFactory(m_rand);
            for ( int classIndex = 0; classIndex < i_classCount; classIndex++)
            {
                List<ClassProperty> props = new List<ClassProperty>();
                int propCount = m_rand.Next(10);
                for(int propIndex = 0; propIndex < propCount; propIndex++)
                {
                    props.Add(m_propFactory.NewProp(.7, 0.0, 28));
                }

                bool hasVTable = m_rand.NextDouble() < m_vTableChance;
                m_classes.Add(new ClassEntry("reflective::details::" + i_hierarchyName, "Class_" + classIndex.ToString(), hasVTable, props));
            }
        }

        public string FileName { get; set; }

        public void Save()
        {
            System.IO.File.WriteAllText(FileName, GenerateSourceCode() );
        }

        public void AddRandomBaseClasses(int i_derivationCount)
        {
            for(int i = 0; i < m_classes.Count; i++ )
            {
                ClassEntry derC = m_classes[i];
                
                for (int j = 0; j < i; j++)
                {
                    ClassEntry baseC = m_classes[j];
                    var existingBases = derC.GetAllBases();
                    var baseBases = baseC.GetAllBases();
                    baseBases.Add(baseC);
                    if( !baseBases.Overlaps(existingBases) )
                    {
                        //Save();
                        //System.Diagnostics.Debug.WriteLine("Adding to " + derC.Name + " the base " + baseC.Name );
                        derC.AddBase(baseC, false);
                    }
                }
            }
            /*int currDer = 0;
            while(currDer < i_derivationCount)
            {
                int firstClass = m_rand.Next(m_classes.Count - 1);
                int secondClass = m_rand.Next(firstClass + 1, m_classes.Count);
                if( !m_classes[secondClass].HasBaseClass(m_classes[firstClass]) )
                {
                    bool vBase = m_rand.NextDouble() < m_vBaseChance;
                    m_classes[secondClass].AddBase(m_classes[firstClass], vBase);
                    if(!m_classes[secondClass].HasBaseClass(m_classes[firstClass]))
                    {
                        int gg = 0;
                    }
                    currDer++;
                }
            } */           
        }

        public string GenerateSourceCode()
        {
            TextOut output = new TextOut();
            output.AppendLine("");
            output.AppendLine("// This source file was generated by hierarchy_test_util");
            output.AppendLine("");
            output.AppendLine("// incudes");
            output.AppendLine(@"#include <string>");
            output.AppendLine(@"#include <iostream>");
            output.AppendLine(@"#include <cstdlib>");
            output.AppendLine(@"#include ""..\sources\reflective.h""");
            output.AppendLine(@"");
            output.AppendLine(@"");

            output.AppendLine("namespace reflective");
            output.AppendLine("{");
            output.Tab();

            output.AppendLine("namespace details");
            output.AppendLine("{");
            output.Tab();

            output.AppendLine("namespace " + m_hierarchyName);
            output.AppendLine("{");
            output.Tab();

            foreach ( ClassEntry classEntry in m_classes)
            {
                classEntry.WriteDefinition(output);
            }

            output.Untab();
            output.AppendLine("};");

            output.Untab();
            output.AppendLine("};");

            output.AppendLine("");
            foreach (ClassEntry classEntry in m_classes)
            {
                classEntry.WriteReflection(output);
            }
            output.Untab();
            output.AppendLine("};");


            return output.ToString();
        }
    }
}
