
// This source file was generated by hierarchy_test_util

// incudes
#include <string>
#include <iostream>
#include <cstdlib>
#include "..\reflective\reflective.h"


 /******** Configuration 
 * hierarchy name: hier
 * class count: 20
 * derivation factor: 1
 * virtual table chance: 50%
 * virtual base chance: 50%
 * allow multiple inheritance: True
 * most-derived-type function chance: 150%
 * test count: 40
 * emit type checks: True
 * random seed: 568
 ********/
namespace reflective
{
	namespace details
	{
		namespace hier
		{
			class Class_0
			{
				public:
				virtual ~Class_0() {}
				virtual int vfunct_Class_0() { return 42; }
				std::string type_name = "Class_0";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_0>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_0 *>(i_object)->virtual_get_type(); }
				unsigned int***** m_prop1;
				signed int******** m_prop2;
				unsigned short int m_prop3;
				signed short int* m_prop4;
			};
			class Class_1
			{
				public:
				std::string type_name = "Class_1";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_1>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_1 *>(i_object)->virtual_get_type(); }
				unsigned long int***** m_prop5;
			};
			class Class_2
			{
				public:
				std::string type_name = "Class_2";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_2>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_2 *>(i_object)->virtual_get_type(); }
			};
			class Class_3 : public virtual Class_2
			{
				public:
				std::string type_name = "Class_3";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_3>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_3 *>(i_object)->virtual_get_type(); }
				signed long int m_prop6;
				unsigned long long int m_prop7;
				signed long long int* m_prop8;
				char** m_prop9;
				unsigned char*** m_prop10;
				signed char m_prop11;
				float** m_prop12;
			};
			class Class_4
			{
				public:
				std::string type_name = "Class_4";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_4>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_4 *>(i_object)->virtual_get_type(); }
				double m_prop13;
			};
			class Class_5 : public virtual Class_2, public virtual Class_4, public virtual Class_0
			{
				public:
				std::string type_name = "Class_5";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_5>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_5 *>(i_object)->virtual_get_type(); }
			};
			class Class_6
			{
				public:
				virtual ~Class_6() {}
				virtual int vfunct_Class_6() { return 42; }
				std::string type_name = "Class_6";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_6>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_6 *>(i_object)->virtual_get_type(); }
				long double*** m_prop14;
				unsigned long long int* m_prop15;
				unsigned short int m_prop16;
				signed int** m_prop17;
				signed long long int** m_prop18;
				long double* m_prop19;
				unsigned int m_prop20;
			};
			class Class_7 : public Class_0, public Class_4, public Class_2, public virtual Class_1
			{
				public:
				std::string type_name = "Class_7";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_7>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_7 *>(i_object)->virtual_get_type(); }
				signed long int* m_prop21;
				signed short int m_prop22;
				signed char** m_prop23;
			};
			class Class_8 : public Class_6, public Class_1
			{
				public:
				virtual ~Class_8() {}
				virtual int vfunct_Class_8() { return 42; }
				std::string type_name = "Class_8";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_8>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_8 *>(i_object)->virtual_get_type(); }
				char m_prop24;
				double* m_prop25;
				float* m_prop26;
				unsigned long int m_prop27;
				unsigned char*** m_prop28;
				signed long int******* m_prop29;
				long double* m_prop30;
			};
			class Class_9 : public Class_6, public virtual Class_0
			{
				public:
				virtual ~Class_9() {}
				virtual int vfunct_Class_9() { return 42; }
				std::string type_name = "Class_9";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_9>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_9 *>(i_object)->virtual_get_type(); }
				unsigned int* m_prop31;
				signed char** m_prop32;
				unsigned char*** m_prop33;
				unsigned long int m_prop34;
				unsigned long long int m_prop35;
				double m_prop36;
				signed short int m_prop37;
			};
			class Class_10 : public virtual Class_1
			{
				public:
				virtual ~Class_10() {}
				virtual int vfunct_Class_10() { return 42; }
				std::string type_name = "Class_10";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_10>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_10 *>(i_object)->virtual_get_type(); }
				char m_prop38;
				unsigned short int m_prop39;
				signed long long int m_prop40;
			};
			class Class_11 : public Class_5, public virtual Class_2, public virtual Class_0, public virtual Class_8, public virtual Class_4
			{
				public:
				virtual ~Class_11() {}
				virtual int vfunct_Class_11() { return 42; }
				std::string type_name = "Class_11";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_11>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_11 *>(i_object)->virtual_get_type(); }
				float m_prop41;
				signed int m_prop42;
				signed int* m_prop43;
				unsigned long int m_prop44;
				float**** m_prop45;
				double*** m_prop46;
				unsigned long long int**** m_prop47;
			};
			class Class_12 : public Class_6, public Class_2, public Class_10, public virtual Class_0
			{
				public:
				virtual ~Class_12() {}
				virtual int vfunct_Class_12() { return 42; }
				std::string type_name = "Class_12";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_12>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_12 *>(i_object)->virtual_get_type(); }
			};
			class Class_13 : public virtual Class_7
			{
				public:
				virtual ~Class_13() {}
				virtual int vfunct_Class_13() { return 42; }
				std::string type_name = "Class_13";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_13>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_13 *>(i_object)->virtual_get_type(); }
				unsigned int****** m_prop48;
				unsigned short int** m_prop49;
				char* m_prop50;
				signed long long int** m_prop51;
				long double****** m_prop52;
			};
			class Class_14 : public virtual Class_13, public virtual Class_1
			{
				public:
				virtual ~Class_14() {}
				virtual int vfunct_Class_14() { return 42; }
				std::string type_name = "Class_14";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_14>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_14 *>(i_object)->virtual_get_type(); }
				signed char m_prop53;
				signed short int* m_prop54;
			};
			class Class_15 : public Class_10, public Class_6, public virtual Class_1, public virtual Class_14
			{
				public:
				std::string type_name = "Class_15";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_15>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_15 *>(i_object)->virtual_get_type(); }
				signed long int m_prop55;
				unsigned char************* m_prop56;
				float* m_prop57;
			};
			class Class_16 : public Class_3, public Class_1, public virtual Class_9, public virtual Class_0, public virtual Class_5
			{
				public:
				std::string type_name = "Class_16";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_16>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_16 *>(i_object)->virtual_get_type(); }
				signed char* m_prop58;
				char**** m_prop59;
			};
			class Class_17 : public Class_5, public Class_3, public virtual Class_8, public virtual Class_2
			{
				public:
				virtual ~Class_17() {}
				virtual int vfunct_Class_17() { return 42; }
				std::string type_name = "Class_17";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_17>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_17 *>(i_object)->virtual_get_type(); }
			};
			class Class_18 : public Class_0, public virtual Class_10, public virtual Class_2, public virtual Class_3, public virtual Class_1
			{
				public:
				virtual ~Class_18() {}
				virtual int vfunct_Class_18() { return 42; }
				std::string type_name = "Class_18";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_18>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_18 *>(i_object)->virtual_get_type(); }
				long double m_prop60;
				unsigned char* m_prop61;
			};
			class Class_19 : public Class_17, public virtual Class_4
			{
				public:
				virtual ~Class_19() {}
				virtual int vfunct_Class_19() { return 42; }
				std::string type_name = "Class_19";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_19>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_19 *>(i_object)->virtual_get_type(); }
				unsigned long int**** m_prop62;
				unsigned short int m_prop63;
				signed long long int m_prop64;
				double**** m_prop65;
				signed short int m_prop66;
				unsigned int*** m_prop67;
				unsigned long long int**** m_prop68;
				signed long int m_prop69;
			};
		}
	}
	
	void setup_type(TypeSetupContext<reflective::details::hier::Class_0> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_0;
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_1> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_1;
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_2> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_2;
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_3> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_3;
		i_context.type()->set_base_types( {
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_2>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		&reflective::get_naked_type<reflective::details::hier::Class_2>(), 
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_4> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_4;
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_5> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_5;
		i_context.type()->set_base_types( {
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_2>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_4>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_0>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		&reflective::get_naked_type<reflective::details::hier::Class_2>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_4>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_0>(), 
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_6> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_6;
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_7> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_7;
		i_context.type()->set_base_types( {
			BaseType::from_types<ThisClass, reflective::details::hier::Class_0>(),
			BaseType::from_types<ThisClass, reflective::details::hier::Class_4>(),
			BaseType::from_types<ThisClass, reflective::details::hier::Class_2>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_1>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		&reflective::get_naked_type<reflective::details::hier::Class_0>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_4>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_2>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_1>(), 
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_8> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_8;
		i_context.type()->set_base_types( {
			BaseType::from_types<ThisClass, reflective::details::hier::Class_6>(),
			BaseType::from_types<ThisClass, reflective::details::hier::Class_1>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		&reflective::get_naked_type<reflective::details::hier::Class_6>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_1>(), 
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_9> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_9;
		i_context.type()->set_base_types( {
			BaseType::from_types<ThisClass, reflective::details::hier::Class_6>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_0>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		&reflective::get_naked_type<reflective::details::hier::Class_6>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_0>(), 
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_10> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_10;
		i_context.type()->set_base_types( {
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_1>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		&reflective::get_naked_type<reflective::details::hier::Class_1>(), 
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_11> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_11;
		i_context.type()->set_base_types( {
			BaseType::from_types<ThisClass, reflective::details::hier::Class_5>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_2>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_0>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_8>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_4>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		&reflective::get_naked_type<reflective::details::hier::Class_5>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_2>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_0>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_8>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_4>(), 
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_12> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_12;
		i_context.type()->set_base_types( {
			BaseType::from_types<ThisClass, reflective::details::hier::Class_6>(),
			BaseType::from_types<ThisClass, reflective::details::hier::Class_2>(),
			BaseType::from_types<ThisClass, reflective::details::hier::Class_10>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_0>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		&reflective::get_naked_type<reflective::details::hier::Class_6>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_2>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_10>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_0>(), 
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_13> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_13;
		i_context.type()->set_base_types( {
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_7>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		&reflective::get_naked_type<reflective::details::hier::Class_7>(), 
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_14> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_14;
		i_context.type()->set_base_types( {
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_13>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_1>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		&reflective::get_naked_type<reflective::details::hier::Class_13>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_1>(), 
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_15> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_15;
		i_context.type()->set_base_types( {
			BaseType::from_types<ThisClass, reflective::details::hier::Class_10>(),
			BaseType::from_types<ThisClass, reflective::details::hier::Class_6>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_1>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_14>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		&reflective::get_naked_type<reflective::details::hier::Class_10>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_6>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_1>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_14>(), 
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_16> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_16;
		i_context.type()->set_base_types( {
			BaseType::from_types<ThisClass, reflective::details::hier::Class_3>(),
			BaseType::from_types<ThisClass, reflective::details::hier::Class_1>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_9>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_0>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_5>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		&reflective::get_naked_type<reflective::details::hier::Class_3>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_1>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_9>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_0>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_5>(), 
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_17> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_17;
		i_context.type()->set_base_types( {
			BaseType::from_types<ThisClass, reflective::details::hier::Class_5>(),
			BaseType::from_types<ThisClass, reflective::details::hier::Class_3>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_8>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_2>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		&reflective::get_naked_type<reflective::details::hier::Class_5>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_3>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_8>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_2>(), 
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_18> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_18;
		i_context.type()->set_base_types( {
			BaseType::from_types<ThisClass, reflective::details::hier::Class_0>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_10>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_2>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_3>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_1>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		&reflective::get_naked_type<reflective::details::hier::Class_0>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_10>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_2>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_3>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_1>(), 
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_19> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_19;
		i_context.type()->set_base_types( {
			BaseType::from_types<ThisClass, reflective::details::hier::Class_17>(),
			BaseType::from_types_virtual<ThisClass, reflective::details::hier::Class_4>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
		
		// test base_types container
		std::vector<const reflective::Type*> test_bases = {
		&reflective::get_naked_type<reflective::details::hier::Class_17>(), 
		&reflective::get_naked_type<reflective::details::hier::Class_4>(), 
		};
		for( const auto & base : i_context.type()->base_types() )
		{
			auto it = reflective::Ext::find_if(test_bases, 
				[&base] (const reflective::Type * i_s) { return i_s == base.base_type(); } );
			REFLECTIVE_INTERNAL_ASSERT( it != test_bases.end() );
			test_bases.erase(it);
		}
		REFLECTIVE_INTERNAL_ASSERT( test_bases.size() == 0 );
	}
};
namespace reflective
{
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_0 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_0");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_1 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_1");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_2 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_2");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_3 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_3");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_4 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_4");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_5 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_5");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_6 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_6");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_7 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_7");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_8 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_8");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_9 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_9");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_10 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_10");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_11 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_11");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_12 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_12");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_13 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_13");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_14 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_14");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_15 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_15");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_16 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_16");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_17 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_17");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_18 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_18");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_19 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_19");
	}
	namespace details
	{
		namespace hier
		{
			struct Stats { int m_test_count = 0; int m_failed_cast_count = 0; };
			
			void test_hier_0(Stats & io_stats)
			{
				// upcasting from Class_17 to Class_5, and then dynamic casting to Class_16
				Class_17 complete_object;
				Class_17 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_5 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_5>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_5*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_5>());
				
				Class_16 * native_dyn_ptr = dynamic_cast<Class_16*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_16>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_16*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_16>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_1(Stats & io_stats)
			{
				// upcasting from Class_12 to Class_6, and then dynamic casting to Class_9
				Class_12 complete_object;
				Class_12 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_6 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_6>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_6*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_6>());
				
				Class_9 * native_dyn_ptr = dynamic_cast<Class_9*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_9>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_9*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_9>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_2(Stats & io_stats)
			{
				// upcasting from Class_15 to Class_0, and then dynamic casting to Class_0
				Class_15 complete_object;
				Class_15 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_0 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_0>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_0*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_0>());
				
				Class_0 * native_dyn_ptr = dynamic_cast<Class_0*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_0>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_0*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_0>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_3(Stats & io_stats)
			{
				// upcasting from Class_9 to Class_9, and then dynamic casting to Class_9
				Class_9 complete_object;
				Class_9 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_9 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_9>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_9*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_9>());
				
				Class_9 * native_dyn_ptr = dynamic_cast<Class_9*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_9>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_9*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_9>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_4(Stats & io_stats)
			{
				// upcasting from Class_15 to Class_15, and then dynamic casting to Class_12
				Class_15 complete_object;
				Class_15 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_15 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_15>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_15*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_15>());
				
				Class_12 * native_dyn_ptr = dynamic_cast<Class_12*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_12>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_12*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_12>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_5(Stats & io_stats)
			{
				// upcasting from Class_11 to Class_2, and then dynamic casting to Class_1
				Class_11 complete_object;
				Class_11 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_2 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_2>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_2*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_2>());
				
				Class_1 * native_dyn_ptr = dynamic_cast<Class_1*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_1>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_1*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_1>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_6(Stats & io_stats)
			{
				// upcasting from Class_10 to Class_1, and then dynamic casting to Class_19
				Class_10 complete_object;
				Class_10 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_1 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_1>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_1*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_1>());
				
				Class_19 * native_dyn_ptr = dynamic_cast<Class_19*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_19>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_19*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_19>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_7(Stats & io_stats)
			{
				// upcasting from Class_0 to Class_0, and then dynamic casting to Class_6
				Class_0 complete_object;
				Class_0 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_0 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_0>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_0*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_0>());
				
				Class_6 * native_dyn_ptr = dynamic_cast<Class_6*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_6>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_6*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_6>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_8(Stats & io_stats)
			{
				// upcasting from Class_17 to Class_8, and then dynamic casting to Class_13
				Class_17 complete_object;
				Class_17 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_8 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_8>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_8*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_8>());
				
				Class_13 * native_dyn_ptr = dynamic_cast<Class_13*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_13>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_13*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_13>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_9(Stats & io_stats)
			{
				// upcasting from Class_4 to Class_4, and then dynamic casting to Class_13
				Class_4 complete_object;
				Class_4 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_4 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_4>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_4*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_4>());
				
				Class_13 * native_dyn_ptr = dynamic_cast<Class_13*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_13>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_13*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_13>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_10(Stats & io_stats)
			{
				// upcasting from Class_1 to Class_1, and then dynamic casting to Class_3
				Class_1 complete_object;
				Class_1 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_1 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_1>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_1*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_1>());
				
				Class_3 * native_dyn_ptr = dynamic_cast<Class_3*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_3>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_3*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_3>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_11(Stats & io_stats)
			{
				// upcasting from Class_4 to Class_4, and then dynamic casting to Class_10
				Class_4 complete_object;
				Class_4 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_4 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_4>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_4*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_4>());
				
				Class_10 * native_dyn_ptr = dynamic_cast<Class_10*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_10>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_10*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_10>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_12(Stats & io_stats)
			{
				// upcasting from Class_11 to Class_5, and then dynamic casting to Class_2
				Class_11 complete_object;
				Class_11 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_5 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_5>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_5*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_5>());
				
				Class_2 * native_dyn_ptr = dynamic_cast<Class_2*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_2>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_2*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_2>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_13(Stats & io_stats)
			{
				// upcasting from Class_11 to Class_11, and then dynamic casting to Class_4
				Class_11 complete_object;
				Class_11 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_11 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_11>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_11*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_11>());
				
				Class_4 * native_dyn_ptr = dynamic_cast<Class_4*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_4>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_4*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_4>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_14(Stats & io_stats)
			{
				// upcasting from Class_8 to Class_6, and then dynamic casting to Class_9
				Class_8 complete_object;
				Class_8 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_6 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_6>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_6*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_6>());
				
				Class_9 * native_dyn_ptr = dynamic_cast<Class_9*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_9>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_9*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_9>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_15(Stats & io_stats)
			{
				// upcasting from Class_1 to Class_1, and then dynamic casting to Class_11
				Class_1 complete_object;
				Class_1 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_1 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_1>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_1*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_1>());
				
				Class_11 * native_dyn_ptr = dynamic_cast<Class_11*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_11>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_11*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_11>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_16(Stats & io_stats)
			{
				// upcasting from Class_12 to Class_1, and then dynamic casting to Class_1
				Class_12 complete_object;
				Class_12 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_1 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_1>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_1*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_1>());
				
				Class_1 * native_dyn_ptr = dynamic_cast<Class_1*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_1>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_1*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_1>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_17(Stats & io_stats)
			{
				// upcasting from Class_1 to Class_1, and then dynamic casting to Class_15
				Class_1 complete_object;
				Class_1 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_1 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_1>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_1*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_1>());
				
				Class_15 * native_dyn_ptr = dynamic_cast<Class_15*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_15>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_15*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_15>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_18(Stats & io_stats)
			{
				// upcasting from Class_17 to Class_0, and then dynamic casting to Class_18
				Class_17 complete_object;
				Class_17 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_0 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_0>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_0*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_0>());
				
				Class_18 * native_dyn_ptr = dynamic_cast<Class_18*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_18>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_18*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_18>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_19(Stats & io_stats)
			{
				// upcasting from Class_10 to Class_10, and then dynamic casting to Class_11
				Class_10 complete_object;
				Class_10 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_10 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_10>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_10*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_10>());
				
				Class_11 * native_dyn_ptr = dynamic_cast<Class_11*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_11>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_11*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_11>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_20(Stats & io_stats)
			{
				// upcasting from Class_15 to Class_1, and then dynamic casting to Class_11
				Class_15 complete_object;
				Class_15 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_1 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_1>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_1*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_1>());
				
				Class_11 * native_dyn_ptr = dynamic_cast<Class_11*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_11>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_11*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_11>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_21(Stats & io_stats)
			{
				// upcasting from Class_7 to Class_2, and then dynamic casting to Class_6
				Class_7 complete_object;
				Class_7 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_2 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_2>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_2*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_2>());
				
				Class_6 * native_dyn_ptr = dynamic_cast<Class_6*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_6>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_6*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_6>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_22(Stats & io_stats)
			{
				// upcasting from Class_6 to Class_6, and then dynamic casting to Class_9
				Class_6 complete_object;
				Class_6 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_6 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_6>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_6*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_6>());
				
				Class_9 * native_dyn_ptr = dynamic_cast<Class_9*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_9>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_9*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_9>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_23(Stats & io_stats)
			{
				// upcasting from Class_2 to Class_2, and then dynamic casting to Class_6
				Class_2 complete_object;
				Class_2 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_2 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_2>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_2*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_2>());
				
				Class_6 * native_dyn_ptr = dynamic_cast<Class_6*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_6>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_6*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_6>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_24(Stats & io_stats)
			{
				// upcasting from Class_18 to Class_18, and then dynamic casting to Class_4
				Class_18 complete_object;
				Class_18 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_18 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_18>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_18*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_18>());
				
				Class_4 * native_dyn_ptr = dynamic_cast<Class_4*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_4>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_4*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_4>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_25(Stats & io_stats)
			{
				// upcasting from Class_14 to Class_1, and then dynamic casting to Class_0
				Class_14 complete_object;
				Class_14 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_1 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_1>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_1*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_1>());
				
				Class_0 * native_dyn_ptr = dynamic_cast<Class_0*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_0>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_0*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_0>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_26(Stats & io_stats)
			{
				// upcasting from Class_17 to Class_0, and then dynamic casting to Class_3
				Class_17 complete_object;
				Class_17 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_0 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_0>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_0*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_0>());
				
				Class_3 * native_dyn_ptr = dynamic_cast<Class_3*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_3>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_3*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_3>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_27(Stats & io_stats)
			{
				// upcasting from Class_2 to Class_2, and then dynamic casting to Class_18
				Class_2 complete_object;
				Class_2 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_2 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_2>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_2*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_2>());
				
				Class_18 * native_dyn_ptr = dynamic_cast<Class_18*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_18>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_18*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_18>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_28(Stats & io_stats)
			{
				// upcasting from Class_11 to Class_5, and then dynamic casting to Class_5
				Class_11 complete_object;
				Class_11 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_5 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_5>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_5*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_5>());
				
				Class_5 * native_dyn_ptr = dynamic_cast<Class_5*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_5>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_5*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_5>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_29(Stats & io_stats)
			{
				// upcasting from Class_7 to Class_4, and then dynamic casting to Class_11
				Class_7 complete_object;
				Class_7 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_4 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_4>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_4*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_4>());
				
				Class_11 * native_dyn_ptr = dynamic_cast<Class_11*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_11>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_11*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_11>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_30(Stats & io_stats)
			{
				// upcasting from Class_11 to Class_5, and then dynamic casting to Class_6
				Class_11 complete_object;
				Class_11 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_5 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_5>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_5*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_5>());
				
				Class_6 * native_dyn_ptr = dynamic_cast<Class_6*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_6>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_6*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_6>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_31(Stats & io_stats)
			{
				// upcasting from Class_11 to Class_4, and then dynamic casting to Class_6
				Class_11 complete_object;
				Class_11 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_4 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_4>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_4*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_4>());
				
				Class_6 * native_dyn_ptr = dynamic_cast<Class_6*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_6>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_6*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_6>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_32(Stats & io_stats)
			{
				// upcasting from Class_13 to Class_0, and then dynamic casting to Class_14
				Class_13 complete_object;
				Class_13 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_0 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_0>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_0*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_0>());
				
				Class_14 * native_dyn_ptr = dynamic_cast<Class_14*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_14>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_14*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_14>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_33(Stats & io_stats)
			{
				// upcasting from Class_2 to Class_2, and then dynamic casting to Class_16
				Class_2 complete_object;
				Class_2 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_2 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_2>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_2*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_2>());
				
				Class_16 * native_dyn_ptr = dynamic_cast<Class_16*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_16>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_16*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_16>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_34(Stats & io_stats)
			{
				// upcasting from Class_1 to Class_1, and then dynamic casting to Class_16
				Class_1 complete_object;
				Class_1 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_1 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_1>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_1*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_1>());
				
				Class_16 * native_dyn_ptr = dynamic_cast<Class_16*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_16>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_16*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_16>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_35(Stats & io_stats)
			{
				// upcasting from Class_15 to Class_6, and then dynamic casting to Class_5
				Class_15 complete_object;
				Class_15 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_6 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_6>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_6*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_6>());
				
				Class_5 * native_dyn_ptr = dynamic_cast<Class_5*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_5>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_5*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_5>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_36(Stats & io_stats)
			{
				// upcasting from Class_10 to Class_1, and then dynamic casting to Class_5
				Class_10 complete_object;
				Class_10 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_1 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_1>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_1*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_1>());
				
				Class_5 * native_dyn_ptr = dynamic_cast<Class_5*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_5>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_5*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_5>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_37(Stats & io_stats)
			{
				// upcasting from Class_17 to Class_2, and then dynamic casting to Class_18
				Class_17 complete_object;
				Class_17 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_2 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_2>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_2*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_2>());
				
				Class_18 * native_dyn_ptr = dynamic_cast<Class_18*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_18>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_18*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_18>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_38(Stats & io_stats)
			{
				// upcasting from Class_7 to Class_1, and then dynamic casting to Class_0
				Class_7 complete_object;
				Class_7 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_1 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_1>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_1*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_1>());
				
				Class_0 * native_dyn_ptr = dynamic_cast<Class_0*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_0>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_0*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_0>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_39(Stats & io_stats)
			{
				// upcasting from Class_12 to Class_1, and then dynamic casting to Class_7
				Class_12 complete_object;
				Class_12 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_1 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_1>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_1*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_1>());
				
				Class_7 * native_dyn_ptr = dynamic_cast<Class_7*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_7>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_7*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_7>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier()
			{
				Stats stats;
				test_hier_0(stats);
				test_hier_1(stats);
				test_hier_2(stats);
				test_hier_3(stats);
				test_hier_4(stats);
				test_hier_5(stats);
				test_hier_6(stats);
				test_hier_7(stats);
				test_hier_8(stats);
				test_hier_9(stats);
				test_hier_10(stats);
				test_hier_11(stats);
				test_hier_12(stats);
				test_hier_13(stats);
				test_hier_14(stats);
				test_hier_15(stats);
				test_hier_16(stats);
				test_hier_17(stats);
				test_hier_18(stats);
				test_hier_19(stats);
				test_hier_20(stats);
				test_hier_21(stats);
				test_hier_22(stats);
				test_hier_23(stats);
				test_hier_24(stats);
				test_hier_25(stats);
				test_hier_26(stats);
				test_hier_27(stats);
				test_hier_28(stats);
				test_hier_29(stats);
				test_hier_30(stats);
				test_hier_31(stats);
				test_hier_32(stats);
				test_hier_33(stats);
				test_hier_34(stats);
				test_hier_35(stats);
				test_hier_36(stats);
				test_hier_37(stats);
				test_hier_38(stats);
				test_hier_39(stats);
			}
		}
	}
}
