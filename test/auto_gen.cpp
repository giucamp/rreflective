
// This source file was generated by hierarchy_test_util

// incudes
#include <string>
#include <iostream>
#include <cstdlib>
#include "..\sources\reflective.h"


 /******** Configuration 
 * hierarchy name: hier
 * class count: 5
 * derivation factor: 5
 * virtual table chance: 50%
 * virtual base chance: 50%
 * allow multiple inheritance: True
 * most-derived-type function chance: 150%
 * test count: 10
 * emit type checks: True
 * random seed: 568
 ********/
namespace reflective
{
	namespace details
	{
		namespace hier
		{
			class Class_0
			{
				public:
				virtual ~Class_0() {}
				virtual int vfunct_Class_0() { return 42; }
				std::string type_name = "Class_0";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_0>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_0 *>(i_object)->virtual_get_type(); }
				unsigned int***** m_prop1;
				signed int******** m_prop2;
				unsigned short int m_prop3;
				signed short int* m_prop4;
			};
			class Class_1 : public Class_0
			{
				public:
				std::string type_name = "Class_1";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_1>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_1 *>(i_object)->virtual_get_type(); }
				unsigned long int***** m_prop5;
			};
			class Class_2 : public Class_0
			{
				public:
				std::string type_name = "Class_2";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_2>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_2 *>(i_object)->virtual_get_type(); }
			};
			class Class_3 : public Class_0
			{
				public:
				std::string type_name = "Class_3";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_3>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_3 *>(i_object)->virtual_get_type(); }
				signed long int m_prop6;
				unsigned long long int m_prop7;
				signed long long int* m_prop8;
				char** m_prop9;
				unsigned char*** m_prop10;
				signed char m_prop11;
				float** m_prop12;
			};
			class Class_4 : public Class_0
			{
				public:
				std::string type_name = "Class_4";
				virtual const reflective::Type & virtual_get_type() const
					{ return reflective::get_naked_type<Class_4>(); }
				
				static const reflective::Type & static_get_type(const void * i_object)
					{ return static_cast<const Class_4 *>(i_object)->virtual_get_type(); }
				double m_prop13;
			};
		}
	}
	
	void setup_type(TypeSetupContext<reflective::details::hier::Class_0> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_0;
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_1> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_1;
		i_context.type()->set_base_types( {
			BaseType::from_types<ThisClass, reflective::details::hier::Class_0>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_2> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_2;
		i_context.type()->set_base_types( {
			BaseType::from_types<ThisClass, reflective::details::hier::Class_0>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_3> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_3;
		i_context.type()->set_base_types( {
			BaseType::from_types<ThisClass, reflective::details::hier::Class_0>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
	}
	void setup_type(TypeSetupContext<reflective::details::hier::Class_4> & i_context)
	{
		using ThisClass = reflective::details::hier::Class_4;
		i_context.type()->set_base_types( {
			BaseType::from_types<ThisClass, reflective::details::hier::Class_0>() });
		i_context.type()->set_most_derived_type_func(&ThisClass::static_get_type);
	}
};
namespace reflective
{
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_0 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_0");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_1 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_1");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_2 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_2");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_3 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_3");
	}
	template <> inline void dbg_object_validate(const reflective::details::hier::Class_4 & i_object)
	{
		REFLECTIVE_INTERNAL_ASSERT(i_object.type_name == "Class_4");
	}
	namespace details
	{
		namespace hier
		{
			struct Stats { int m_test_count = 0; int m_failed_cast_count = 0; };
			
			void test_hier_0(Stats & io_stats)
			{
				// upcasting from Class_2 to Class_2, and the dynamic casting to Class_2
				Class_2 complete_object;
				Class_2 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_2 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_2>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_2*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_2>());
				
				Class_2 * native_dyn_ptr = dynamic_cast<Class_2*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_2>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_2*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_2>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_1(Stats & io_stats)
			{
				// upcasting from Class_1 to Class_1, and the dynamic casting to Class_4
				Class_1 complete_object;
				Class_1 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_1 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_1>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_1*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_1>());
				
				Class_4 * native_dyn_ptr = dynamic_cast<Class_4*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_4>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_4*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_4>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_2(Stats & io_stats)
			{
				// upcasting from Class_4 to Class_0, and the dynamic casting to Class_0
				Class_4 complete_object;
				Class_4 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_0 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_0>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_0*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_0>());
				
				Class_0 * native_dyn_ptr = dynamic_cast<Class_0*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_0>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_0*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_0>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_3(Stats & io_stats)
			{
				// upcasting from Class_3 to Class_0, and the dynamic casting to Class_3
				Class_3 complete_object;
				Class_3 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_0 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_0>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_0*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_0>());
				
				Class_3 * native_dyn_ptr = dynamic_cast<Class_3*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_3>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_3*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_3>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_4(Stats & io_stats)
			{
				// upcasting from Class_0 to Class_0, and the dynamic casting to Class_2
				Class_0 complete_object;
				Class_0 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_0 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_0>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_0*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_0>());
				
				Class_2 * native_dyn_ptr = dynamic_cast<Class_2*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_2>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_2*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_2>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_5(Stats & io_stats)
			{
				// upcasting from Class_0 to Class_0, and the dynamic casting to Class_4
				Class_0 complete_object;
				Class_0 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_0 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_0>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_0*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_0>());
				
				Class_4 * native_dyn_ptr = dynamic_cast<Class_4*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_4>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_4*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_4>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_6(Stats & io_stats)
			{
				// upcasting from Class_0 to Class_0, and the dynamic casting to Class_2
				Class_0 complete_object;
				Class_0 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_0 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_0>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_0*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_0>());
				
				Class_2 * native_dyn_ptr = dynamic_cast<Class_2*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_2>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_2*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_2>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_7(Stats & io_stats)
			{
				// upcasting from Class_1 to Class_0, and the dynamic casting to Class_4
				Class_1 complete_object;
				Class_1 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_0 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_0>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_0*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_0>());
				
				Class_4 * native_dyn_ptr = dynamic_cast<Class_4*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_4>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_4*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_4>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_8(Stats & io_stats)
			{
				// upcasting from Class_0 to Class_0, and the dynamic casting to Class_0
				Class_0 complete_object;
				Class_0 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_0 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_0>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_0*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_0>());
				
				Class_0 * native_dyn_ptr = dynamic_cast<Class_0*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_0>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_0*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_0>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier_9(Stats & io_stats)
			{
				// upcasting from Class_1 to Class_0, and the dynamic casting to Class_4
				Class_1 complete_object;
				Class_1 * native_complete_ptr = &complete_object;
				ObjPtr ref_complete_ptr = &complete_object;
				
				Class_0 * native_base_ptr = native_complete_ptr;
				ObjPtr ref_base_ptr = ref_complete_ptr.upcast_to(get_type<Class_0>());
				REFLECTIVE_INTERNAL_ASSERT(native_base_ptr == static_cast<Class_0*>( ref_base_ptr.object() ) );
				reflective::dbg_object_validate(*ref_base_ptr.get_if_type_matches<Class_0>());
				
				Class_4 * native_dyn_ptr = dynamic_cast<Class_4*>(native_base_ptr);
				ObjPtr ref_dyn_ptr = ref_base_ptr.cast_to(get_type<Class_4>());
				REFLECTIVE_INTERNAL_ASSERT( native_dyn_ptr == static_cast<Class_4*>( ref_dyn_ptr.object() ) );
				if( !ref_dyn_ptr.empty() )
				{
					reflective::dbg_object_validate(*ref_dyn_ptr.get_if_type_matches<Class_4>());
				}
				
				io_stats.m_test_count++;
				if(native_dyn_ptr == nullptr)
					io_stats.m_failed_cast_count++;
			}
			void test_hier()
			{
				Stats stats;
				test_hier_0(stats);
				test_hier_1(stats);
				test_hier_2(stats);
				test_hier_3(stats);
				test_hier_4(stats);
				test_hier_5(stats);
				test_hier_6(stats);
				test_hier_7(stats);
				test_hier_8(stats);
				test_hier_9(stats);
			}
		}
	}
}
